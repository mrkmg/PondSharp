{"version":3,"file":"2612.js","mappings":"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","sources":["webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/base/common/iterator.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/base/common/linkedList.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/base/common/process.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/base/common/uint.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/core/position.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/core/range.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","webpack://pondsharp.client/./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        for (const element of iterable) {\n            yield fn(element);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concat = concat;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n})(Iterable || (Iterable = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Node {\n    constructor(element) {\n        this.element = element;\n        this.next = Node.Undefined;\n        this.prev = Node.Undefined;\n    }\n}\nNode.Undefined = new Node(undefined);\nexport class LinkedList {\n    constructor() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    isEmpty() {\n        return this._first === Node.Undefined;\n    }\n    clear() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    unshift(element) {\n        return this._insert(element, false);\n    }\n    push(element) {\n        return this._insert(element, true);\n    }\n    _insert(element, atTheEnd) {\n        const newNode = new Node(element);\n        if (this._first === Node.Undefined) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            const oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            const oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        this._size += 1;\n        let didRemove = false;\n        return () => {\n            if (!didRemove) {\n                didRemove = true;\n                this._remove(newNode);\n            }\n        };\n    }\n    shift() {\n        if (this._first === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._first.element;\n            this._remove(this._first);\n            return res;\n        }\n    }\n    pop() {\n        if (this._last === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._last.element;\n            this._remove(this._last);\n            return res;\n        }\n    }\n    _remove(node) {\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n            // middle\n            const anchor = node.prev;\n            anchor.next = node.next;\n            node.next.prev = anchor;\n        }\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n            // only node\n            this._first = Node.Undefined;\n            this._last = Node.Undefined;\n        }\n        else if (node.next === Node.Undefined) {\n            // last\n            this._last = this._last.prev;\n            this._last.next = Node.Undefined;\n        }\n        else if (node.prev === Node.Undefined) {\n            // first\n            this._first = this._first.next;\n            this._first.prev = Node.Undefined;\n        }\n        // done\n        this._size -= 1;\n    }\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            yield node.element;\n            node = node.next;\n        }\n    }\n    toArray() {\n        const result = [];\n        for (let node = this._first; node !== Node.Undefined; node = node.next) {\n            result.push(node.element);\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isWindows, isMacintosh, setImmediate } from './platform.js';\nconst safeProcess = (typeof process === 'undefined') ? {\n    cwd() { return '/'; },\n    env: Object.create(null),\n    get platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n    nextTick(callback) { return setImmediate(callback); }\n} : process;\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function toUint8(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 255 /* MAX_UINT_8 */) {\n        return 255 /* MAX_UINT_8 */;\n    }\n    return v | 0;\n}\nexport function toUint32(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 4294967295 /* MAX_UINT_32 */) {\n        return 4294967295 /* MAX_UINT_32 */;\n    }\n    return v | 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        let aLineNumber = a.lineNumber | 0;\n        let bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            let aColumn = a.column | 0;\n            let bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        let otherStartLineNumber = b.startLineNumber;\n        let otherStartColumn = b.startColumn;\n        let otherEndLineNumber = b.endLineNumber;\n        let otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* LTR */;\n        }\n        return 1 /* RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Represents information about a specific difference between two sequences.\n */\nexport class DiffChange {\n    /**\n     * Constructs a new DiffChange with the given sequence information\n     * and content.\n     */\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n        this.originalStart = originalStart;\n        this.originalLength = originalLength;\n        this.modifiedStart = modifiedStart;\n        this.modifiedLength = modifiedLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the original sequence.\n     */\n    getOriginalEnd() {\n        return this.originalStart + this.originalLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the modified sequence.\n     */\n    getModifiedEnd() {\n        return this.modifiedStart + this.modifiedLength;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport class StringDiffSequence {\n    constructor(source) {\n        this.source = source;\n    }\n    getElements() {\n        const source = this.source;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            characters[i] = source.charCodeAt(i);\n        }\n        return characters;\n    }\n}\nexport function stringDiff(original, modified, pretty) {\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nexport class Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nexport class MyArray {\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    MarkNextChange() {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n    /**\n     * Constructs the DiffFinder\n     */\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = new Int32Array(elements.length);\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], new Int32Array(elements), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We did't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        let changeHelper = new DiffChangeHelper();\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = new Int32Array(numDiagonals);\n        const reversePoints = new Int32Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    PrettifyChanges(changes) {\n        // Shift all the changes down first\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop &&\n                change.modifiedStart + change.modifiedLength < modifiedStop &&\n                (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&\n                (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            let mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                if (prevChange.originalLength > 0) {\n                    originalStop = prevChange.originalStart + prevChange.originalLength;\n                }\n                if (prevChange.modifiedLength > 0) {\n                    modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n                }\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n        }\n        return changes;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    ConcatenateChanges(left, right) {\n        let mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            const result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        return this._columns[i];\n    }\n    getEndLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getEndColumn(i) {\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        let originalStartLineNumber;\n        let originalStartColumn;\n        let originalEndLineNumber;\n        let originalEndColumn;\n        let modifiedStartLineNumber;\n        let modifiedStartColumn;\n        let modifiedEndLineNumber;\n        let modifiedEndColumn;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = 0;\n            originalStartColumn = 0;\n            originalEndLineNumber = 0;\n            originalEndColumn = 0;\n        }\n        else {\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = 0;\n            modifiedStartColumn = 0;\n            modifiedEndLineNumber = 0;\n            modifiedEndColumn = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n            if (shouldPostProcessCharChanges) {\n                rawChanges = postProcessCharChanges(rawChanges);\n            }\n            charChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nexport class Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            let [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        let states = new Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            let [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* Start */, 104 /* h */, 2 /* H */],\n            [1 /* Start */, 72 /* H */, 2 /* H */],\n            [1 /* Start */, 102 /* f */, 6 /* F */],\n            [1 /* Start */, 70 /* F */, 6 /* F */],\n            [2 /* H */, 116 /* t */, 3 /* HT */],\n            [2 /* H */, 84 /* T */, 3 /* HT */],\n            [3 /* HT */, 116 /* t */, 4 /* HTT */],\n            [3 /* HT */, 84 /* T */, 4 /* HTT */],\n            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],\n            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],\n            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],\n            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],\n            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],\n            [6 /* F */, 105 /* i */, 7 /* FI */],\n            [6 /* F */, 73 /* I */, 7 /* FI */],\n            [7 /* FI */, 108 /* l */, 8 /* FIL */],\n            [7 /* FI */, 76 /* L */, 8 /* FIL */],\n            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],\n            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],\n            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],\n            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],\n            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* None */);\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)\n                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        let result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 41 /* CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        case 91 /* OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 93 /* CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        case 123 /* OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 125 /* CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        /* The following three rules make it that ' or \" or ` are allowed inside links if the link began with a different one */\n                        case 39 /* SingleQuote */:\n                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 34 /* DoubleQuote */:\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 96 /* BackTick */:\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 42 /* Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* Asterisk */) ? 1 /* ForceTermination */ : 0 /* None */;\n                            break;\n                        case 124 /* Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* Pipe */) ? 1 /* ForceTermination */ : 0 /* None */;\n                            break;\n                        case 32 /* Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* End */) {\n                    let chClass;\n                    if (chCode === 91 /* OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            let result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            let result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        let numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        let precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        let n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { mergeSort } from '../../../base/common/arrays.js';\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { globals } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DiffComputer } from '../diff/diffComputer.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../model/wordHelper.js';\nimport { computeLinks } from '../modes/linkComputer.js';\nimport { BasicInplaceReplace } from '../modes/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from '../standalone/standaloneBase.js';\nimport * as types from '../../../base/common/types.js';\n/**\n * @internal\n */\nclass MirrorModel extends BaseMirrorModel {\n    get uri() {\n        return this._uri;\n    }\n    get version() {\n        return this._versionId;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        let content = this._lines[lineNumber - 1];\n        let ranges = this._wordenize(content, wordDefinition);\n        let words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        let lineEnding = this._eol;\n        let startLineIndex = range.startLineNumber - 1;\n        let endLineIndex = range.endLineNumber - 1;\n        let resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        let out = this._lineStarts.getIndexOf(offset);\n        let lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            let maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker {\n    constructor(host, foreignModuleFactory) {\n        this._host = host;\n        this._models = Object.create(null);\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    dispose() {\n        this._models = Object.create(null);\n    }\n    _getModel(uri) {\n        return this._models[uri];\n    }\n    _getModels() {\n        let all = [];\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    acceptNewModel(data) {\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n    }\n    acceptModelChanged(strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        let model = this._models[strURL];\n        model.onEvents(e);\n    }\n    acceptRemovedModel(strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const original = this._getModel(originalUrl);\n            const modified = this._getModel(modifiedUrl);\n            if (!original || !modified) {\n                return null;\n            }\n            const originalLines = original.getLinesContent();\n            const modifiedLines = modified.getLinesContent();\n            const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n                shouldComputeCharChanges: true,\n                shouldPostProcessCharChanges: true,\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n                shouldMakePrettyDiff: true,\n                maxComputationTime: maxComputationTime\n            });\n            const diffResult = diffComputer.computeDiff();\n            const identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified));\n            return {\n                quitEarly: diffResult.quitEarly,\n                identical: identical,\n                changes: diffResult.changes\n            };\n        });\n    }\n    _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    computeMoreMinimalEdits(modelUrl, edits) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return edits;\n            }\n            const result = [];\n            let lastEol = undefined;\n            edits = mergeSort(edits, (a, b) => {\n                if (a.range && b.range) {\n                    return Range.compareRangesUsingStarts(a.range, b.range);\n                }\n                // eol only changes should go to the end\n                let aRng = a.range ? 0 : 1;\n                let bRng = b.range ? 0 : 1;\n                return aRng - bRng;\n            });\n            for (let { range, text, eol } of edits) {\n                if (typeof eol === 'number') {\n                    lastEol = eol;\n                }\n                if (Range.isEmpty(range) && !text) {\n                    // empty change\n                    continue;\n                }\n                const original = model.getValueInRange(range);\n                text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n                if (original === text) {\n                    // noop\n                    continue;\n                }\n                // make sure diff won't take too long\n                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                    result.push({ range, text });\n                    continue;\n                }\n                // compute diff between original and edit.text\n                const changes = stringDiff(original, text, false);\n                const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n                for (const change of changes) {\n                    const start = model.positionAt(editOffset + change.originalStart);\n                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                    const newEdit = {\n                        text: text.substr(change.modifiedStart, change.modifiedLength),\n                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                    };\n                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                        result.push(newEdit);\n                    }\n                }\n            }\n            if (typeof lastEol === 'number') {\n                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n            }\n            return result;\n        });\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    computeLinks(modelUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            return computeLinks(model);\n        });\n    }\n    textualSuggest(modelUrl, position, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            const words = [];\n            const seen = new Set();\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const wordAt = model.getWordAtPosition(position, wordDefRegExp);\n            if (wordAt) {\n                seen.add(model.getValueInRange(wordAt));\n            }\n            for (let word of model.words(wordDefRegExp)) {\n                if (seen.has(word)) {\n                    continue;\n                }\n                seen.add(word);\n                if (!isNaN(Number(word))) {\n                    continue;\n                }\n                words.push(word);\n                if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                    break;\n                }\n            }\n            return words;\n        });\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return Object.create(null);\n            }\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const result = Object.create(null);\n            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n                let words = model.getLineWords(line, wordDefRegExp);\n                for (const word of words) {\n                    if (!isNaN(Number(word.word))) {\n                        continue;\n                    }\n                    let array = result[word.word];\n                    if (!array) {\n                        array = [];\n                        result[word.word] = array;\n                    }\n                    array.push({\n                        startLineNumber: line,\n                        startColumn: word.startColumn,\n                        endLineNumber: line,\n                        endColumn: word.endColumn\n                    });\n                }\n            }\n            return result;\n        });\n    }\n    //#endregion\n    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            let wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            if (range.startColumn === range.endColumn) {\n                range = {\n                    startLineNumber: range.startLineNumber,\n                    startColumn: range.startColumn,\n                    endLineNumber: range.endLineNumber,\n                    endColumn: range.endColumn + 1\n                };\n            }\n            let selectionText = model.getValueInRange(range);\n            let wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n            if (!wordRange) {\n                return null;\n            }\n            let word = model.getValueInRange(wordRange);\n            let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n            return result;\n        });\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.fhr(method, args);\n        };\n        const foreignHost = types.createProxyObject(foreignHostMethods, proxyMethodRequest);\n        let ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(types.getAllMethodNames(this._foreignModule));\n        }\n        // ESM-comment-begin\n        // \t\treturn new Promise<any>((resolve, reject) => {\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n        // \n        // \t\t\t\tresolve(types.getAllMethodNames(this._foreignModule));\n        // \n        // \t\t\t}, reject);\n        // \t\t});\n        // ESM-comment-end\n        // ESM-uncomment-begin\n        return Promise.reject(new Error(`Unexpected usage`));\n        // ESM-uncomment-end\n    }\n    // foreign method request\n    fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host) {\n    return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globals.monaco = createMonacoBaseAPI();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from '../viewModel/prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        let insertLines = insertText.split(/\\r\\n|\\r|\\n/);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        let newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { KeyChord } from '../../../base/common/keyCodes.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Token } from '../core/token.js';\nimport * as standaloneEnums from './standaloneEnums.js';\nexport class KeyMod {\n    static chord(firstPart, secondPart) {\n        return KeyChord(firstPart, secondPart);\n    }\n}\nKeyMod.CtrlCmd = 2048 /* CtrlCmd */;\nKeyMod.Shift = 1024 /* Shift */;\nKeyMod.Alt = 512 /* Alt */;\nKeyMod.WinCtrl = 256 /* WinCtrl */;\nexport function createMonacoBaseAPI() {\n    return {\n        editor: undefined,\n        languages: undefined,\n        CancellationTokenSource: CancellationTokenSource,\n        Emitter: Emitter,\n        KeyCode: standaloneEnums.KeyCode,\n        KeyMod: KeyMod,\n        Position: Position,\n        Range: Range,\n        Selection: Selection,\n        SelectionDirection: standaloneEnums.SelectionDirection,\n        MarkerSeverity: standaloneEnums.MarkerSeverity,\n        MarkerTag: standaloneEnums.MarkerTag,\n        Uri: URI,\n        Token: Token\n    };\n}\n"],"names":["Iterable","is","thing","Symbol","iterator","_empty","Object","freeze","empty","single","element","from","iterable","first","next","value","some","predicate","filter","map","fn","concat","iterables","consume","atMost","Number","POSITIVE_INFINITY","consumed","i","done","push","Node","constructor","this","Undefined","prev","undefined","LinkedList","_first","_last","_size","size","isEmpty","clear","unshift","_insert","atTheEnd","newNode","oldLast","oldFirst","didRemove","_remove","shift","res","pop","node","anchor","toArray","result","safeProcess","process","cwd","env","create","platform","nextTick","callback","toUint8","v","toUint32","Position","lineNumber","column","with","newLineNumber","newColumn","delta","deltaLineNumber","deltaColumn","equals","other","static","a","b","isBefore","isBeforeOrEqual","aLineNumber","bLineNumber","clone","toString","pos","obj","Range","startLineNumber","startColumn","endLineNumber","endColumn","range","containsPosition","position","containsRange","otherRange","strictContainsRange","plusRange","Math","min","max","intersectRanges","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","equalsRange","getEndPosition","getStartPosition","setEndPosition","setStartPosition","collapseToStart","start","end","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","Selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","super","equalsSelection","selectionsEqual","getDirection","getPosition","sel","length","len","direction","DiffChange","originalStart","originalLength","modifiedStart","modifiedLength","getOriginalEnd","getModifiedEnd","StringDiffSequence","source","getElements","characters","Int32Array","charCodeAt","stringDiff","original","modified","pretty","LcsDiff","ComputeDiff","changes","Debug","condition","message","Error","MyArray","sourceArray","sourceIndex","destinationArray","destinationIndex","DiffChangeHelper","m_changes","m_originalStart","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","AddOriginalElement","originalIndex","modifiedIndex","AddModifiedElement","getChanges","getReverseChanges","reverse","originalSequence","modifiedSequence","continueProcessingPredicate","ContinueProcessingPredicate","originalStringElements","originalElementsOrHash","originalHasStrings","_getElements","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","_hasStrings","_originalStringElements","_originalElementsOrHash","_modifiedStringElements","_modifiedElementsOrHash","m_forwardHistory","m_reverseHistory","arr","sequence","elements","_isStringArray","hashes","ElementsAreEqual","newIndex","OriginalElementsAreEqual","index1","index2","ModifiedElementsAreEqual","_ComputeDiff","originalEnd","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","PrettifyChanges","quitEarly","Assert","midOriginalArr","midModifiedArr","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","originalStartPoint","modifiedStartPoint","lastForwardChange","maxDifferences","numDiagonals","numDifferences","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","tempOriginalIndex","abs","matchLengthOfLongest","temp","Copy2","change","originalStop","modifiedStop","checkOriginal","checkModified","mergedChangeArr","ChangesOverlap","splice","prevChange","bestDelta","bestScore","_boundaryScore","score","_OriginalIsBoundary","index","test","_OriginalRegionIsBoundary","_ModifiedIsBoundary","_ModifiedRegionIsBoundary","left","right","Array","Copy","diagonalBaseIndex","diffEven","computeDiff","LineSequence","lines","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","substring","getStartLineNumber","getEndLineNumber","createCharSequence","shouldIgnoreTrimWhitespace","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","col","CharSequence","_charCodes","_lineNumbers","_columns","getStartColumn","getEndColumn","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","diffChange","originalCharSequence","modifiedCharSequence","LineChange","charChanges","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","rawChanges","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","createFromDiffChange","DiffComputer","originalLines","modifiedLines","opts","shouldMakePrettyDiff","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","strings","maximumRuntime","startTime","Date","now","Uint8Matrix","rows","cols","data","Uint8Array","_data","get","row","set","StateMachine","edges","maxCharCode","maxState","chCode","to","states","_states","_maxCharCode","nextState","currentState","_stateMachine","_classifier","LinkComputer","classifier","line","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","url","model","stateMachine","getStateMachine","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","getClassifier","lineCount","getLineCount","getLineContent","j","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","_createLink","BasicInplaceReplace","_defaultValueSet","navigateValueSet","range1","text1","range2","text2","up","doNavigateValueSet","text","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","n2","parseFloat","isNaN","floor","String","valueSetsReplace","valueSets","valueSetReplace","valueSet","idx","indexOf","INSTANCE","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","e","rejected","then","apply","MirrorModel","uri","eol","versionId","_uri","_lines","_eol","_versionId","_lineStarts","_cachedTextValue","dispose","getText","join","onEvents","_acceptDeleteRange","_acceptInsertText","_ensureLineStarts","eolLength","linesLength","lineStartValues","Uint32Array","_setLineText","lineIndex","newValue","changeValue","removeValues","insertText","insertLines","split","newLengths","insertValues","version","getValue","getLinesContent","slice","getWordAtPosition","wordDefinition","wordAtText","words","wordenize","_wordenize","bind","lineText","wordRangesIdx","wordRanges","getLineWords","content","ranges","word","match","lastIndex","exec","getValueInRange","_validateRange","lineEnding","startLineIndex","endLineIndex","resultLines","offsetAt","_validatePosition","getAccumulatedValue","positionAt","offset","out","getIndexOf","lineLength","remainder","hasChanged","maxCharacter","EditorSimpleWorker","host","foreignModuleFactory","_host","_models","_foreignModuleFactory","_foreignModule","_getModel","_getModels","all","keys","forEach","key","acceptNewModel","EOL","acceptModelChanged","strURL","acceptRemovedModel","originalUrl","modifiedUrl","ignoreTrimWhitespace","identical","_modelsAreIdentical","originalLineCount","computeMoreMinimalEdits","modelUrl","edits","lastEol","replace","_diffLimit","editOffset","newEdit","substr","computeLinks","textualSuggest","wordDef","wordDefFlags","seen","Set","wordDefRegExp","RegExp","wordAt","add","has","_suggestionsLimit","computeWordRanges","array","selectionText","wordRange","loadForeignModule","moduleId","createData","foreignHostMethods","ctx","types","method","args","fhr","getMirrorModels","fmr","importScripts","KeyMod","firstPart","secondPart","createMonacoBaseAPI","editor","languages","CancellationTokenSource","Emitter","KeyCode","SelectionDirection","MarkerSeverity","MarkerTag","Uri","Token","CtrlCmd","Shift","Alt","WinCtrl"],"sourceRoot":""}